* 업캐스팅 : 자식이 부모타입으로 형변환
               부모 레퍼런스에 자식의 인스턴스를 저장

-장점 : 어디든 내가 원하는 형태로 쓸 수 있다
-그러나, 내부가 어떤 형태인지 알 수 없으므로
 다운캐스팅하여 열어봐야됨??

오브젝트 안에 스트링을 넣는다

(스택영역)   | O | <--- | S |
 		     ^
		| Object |
		|---------|
(힙영역)              	|    "id"  |

new 객체를 하는 순간 힙에 객체가 생긴다.
객체가 만들어질 때 부모객체가 같이 만들어진다.
스트링의 부모인 오브젝트가 만들어지고 같이 움직인다.

상속의 전제조건? 상속받을 대상이 있어야함 
		=> 그래서 객체를 만들 때 부모객체도 같이 만들어짐

(( 업캐스팅은 상속받은 부분만 사용할 수 있다. ))
위에서 상속받은 것은 오브젝트.. 
즉 업캐스팅을 했을 때 상속받은 오브젝트만 쓸 수 있고 "id"는 쓸 수 없는 상황
다운캐스팅을 하면 가려졌던 "id"를 사용할 수 있음

* 다운캐스팅 : 부모가 자식타입으로 형변환
                  자식의 레퍼런스에 부모의 인스턴스를 저장

※ 오브젝트 : 쉽게 가지고 다니는 덩어리..
   쓸려면 꺼내서 써야한다

--------------------------------------------------------------------------------------------------------

메서드를 만들 때 전달인자를 잘 정해야됨 
기본형은 int double 등..8개지만
참조형은 무한대로 굉장히 다양하므로 
대표하는 오브젝트를 만들어 사용함

--------------------------------------------------------------------------------------------------------

코드 예제) Test2.java

부모는 자식 메서드를 사용할 수 없고 자식은 부모 메서드를 사용할 수 있다.

객체생성 ==> Parent p = new Parent();
업캐스팅 ==> Parent p = new Child();
(자동형변환)

부모메소드에 pprn() 자식메소드에 cprn()이 있을 경우
업캐스팅 == Parent p = new Child();
p1.pprn(); 사용가능 
p1.cprn(); 사용불가
=> 업캐스팅하면 상속받은 것만 사용할 수 있기 때문

다운캐스팅

Child c1 = new Parent();
=> 에러 발생 이유 : 

* 업캐스팅/다운캐스팅 시에는 2번에 단계를 사용해서 에러체크
 1) 컴파일시 - 컴파일오류 체크
     강제형변환 => 컴파일러에게 문제가 있음을 알고, 그래도 진행한다는 의미
     Child c1 = (Child)new Parent();
 2) 실행시 - 예외를 체크(메모리 생성)
     강제형변환 시 콘솔에 에러가 뜸

다운캐스팅 

Child c2 = (Child)p2;
c2.cprn();
c2.pprn();

* 업캐스팅 : 데이터를 받아 들이는 경우
* 다운캐스팅 : 데이터를 꺼내쓸때 사용